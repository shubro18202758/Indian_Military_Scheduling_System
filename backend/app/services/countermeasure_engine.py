"""
AI Countermeasure Engine - Advanced Heuristics for Obstacle Response

This module implements sophisticated decision-making algorithms to counter
obstacles generated by the AI. It demonstrates the system's resilience
and adaptive capabilities.

Algorithms implemented:
1. Route Diversion Optimizer (Graph-based)
2. Convoy Priority Reassessment (Multi-factor scoring)
3. Resource Allocation Optimizer (Constraint satisfaction)
4. Risk-Adjusted ETA Predictor (Probabilistic model)
5. Emergency Response Coordinator (Rule-based + ML)
"""

import asyncio
import math
import random
from datetime import datetime, timedelta
from typing import List, Dict, Tuple, Optional, Any
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update

from app.models.obstacle import Obstacle, Countermeasure, SimulationEvent
from app.models.route import Route
from app.models.convoy import Convoy
from app.models.asset import TransportAsset


# Countermeasure decision matrix
COUNTERMEASURE_RULES = {
    # Obstacle type -> Recommended actions with conditions
    "LANDSLIDE": {
        "HIGH_SEVERITY": ["ROUTE_DIVERSION", "CONVOY_HALT", "SCHEDULE_DELAY"],
        "CRITICAL_SEVERITY": ["ROUTE_DIVERSION", "EMERGENCY_PROTOCOL", "CONVOY_HALT"],
        "MEDIUM_SEVERITY": ["SPEED_ADJUSTMENT", "WAIT_AND_MONITOR", "SCHEDULE_DELAY"]
    },
    "IED_SUSPECTED": {
        "ANY": ["CONVOY_HALT", "EMERGENCY_PROTOCOL", "ROUTE_DIVERSION"],
        "IMMEDIATE": True
    },
    "AMBUSH_RISK": {
        "HIGH_SEVERITY": ["ESCORT_REQUEST", "CONVOY_MERGE", "SCHEDULE_DELAY"],
        "CRITICAL_SEVERITY": ["ROUTE_DIVERSION", "CONVOY_HALT", "EMERGENCY_PROTOCOL"]
    },
    "WEATHER_SEVERE": {
        "ANY": ["SPEED_ADJUSTMENT", "CONVOY_HALT", "WAIT_AND_MONITOR"]
    },
    "FLOODING": {
        "HIGH_SEVERITY": ["ROUTE_DIVERSION", "CONVOY_HALT"],
        "MEDIUM_SEVERITY": ["SPEED_ADJUSTMENT", "WAIT_AND_MONITOR"]
    },
    "BRIDGE_DAMAGE": {
        "ANY": ["ROUTE_DIVERSION", "CONVOY_HALT", "ASSET_REASSIGNMENT"]
    },
    "DEFAULT": {
        "CRITICAL": ["CONVOY_HALT", "ROUTE_DIVERSION", "EMERGENCY_PROTOCOL"],
        "HIGH": ["ROUTE_DIVERSION", "SPEED_ADJUSTMENT", "SCHEDULE_DELAY"],
        "MEDIUM": ["SPEED_ADJUSTMENT", "WAIT_AND_MONITOR"],
        "LOW": ["WAIT_AND_MONITOR", "SPEED_ADJUSTMENT"]
    }
}

# Algorithm configurations
ALGORITHMS = {
    "DIJKSTRA_DIVERSION": {
        "name": "Dijkstra Route Diversion",
        "confidence_base": 0.85,
        "description": "Graph-based shortest path avoiding obstacle zone"
    },
    "PRIORITY_REBALANCE": {
        "name": "Multi-Factor Priority Rebalancer",
        "confidence_base": 0.90,
        "description": "Recalculates convoy priorities based on obstacle impact"
    },
    "GREEDY_REASSIGNMENT": {
        "name": "Greedy Asset Reassignment",
        "confidence_base": 0.80,
        "description": "Reassigns assets to minimize total delay"
    },
    "MONTE_CARLO_ETA": {
        "name": "Monte Carlo ETA Adjustment",
        "confidence_base": 0.75,
        "description": "Probabilistic ETA recalculation with obstacle impact"
    },
    "RULE_BASED_EMERGENCY": {
        "name": "Rule-Based Emergency Protocol",
        "confidence_base": 0.95,
        "description": "Immediate response based on threat classification"
    },
    "CONSTRAINT_SATISFACTION": {
        "name": "Constraint Satisfaction Optimizer",
        "confidence_base": 0.82,
        "description": "Finds optimal resource allocation under constraints"
    }
}


class CountermeasureEngine:
    """
    AI-powered countermeasure engine that responds to obstacles.
    Implements multiple heuristic algorithms for decision-making.
    """
    
    def __init__(self, db: AsyncSession):
        self.db = db
        self.decision_count = 0
        
    async def analyze_obstacle(self, obstacle: Obstacle) -> Dict[str, Any]:
        """Analyze obstacle and determine threat level"""
        analysis = {
            "obstacle_id": obstacle.id,
            "threat_level": obstacle.severity,
            "impact_score": obstacle.impact_score,
            "blocks_route": obstacle.blocks_route,
            "affected_convoys": [],
            "affected_routes": [obstacle.route_id] if obstacle.route_id else [],
            "recommended_actions": [],
            "urgency": "NORMAL"
        }
        
        # Determine urgency
        if obstacle.severity == "CRITICAL" or obstacle.obstacle_type in ["IED_SUSPECTED", "AMBUSH_RISK"]:
            analysis["urgency"] = "IMMEDIATE"
        elif obstacle.severity == "HIGH" or obstacle.blocks_route:
            analysis["urgency"] = "HIGH"
        elif obstacle.severity == "MEDIUM":
            analysis["urgency"] = "MODERATE"
        
        # Find affected convoys
        result = await self.db.execute(
            select(Convoy).where(
                Convoy.route_id == obstacle.route_id,
                Convoy.status.in_(["IN_TRANSIT", "SCHEDULED", "HALTED"])
            )
        )
        convoys = result.scalars().all()
        
        for convoy in convoys:
            if convoy.current_lat and convoy.current_long:
                dist = self._haversine(
                    convoy.current_lat, convoy.current_long,
                    obstacle.latitude, obstacle.longitude
                )
                if dist < 50:  # Within 50km
                    analysis["affected_convoys"].append({
                        "id": convoy.id,
                        "name": convoy.name,
                        "distance_km": round(dist, 1),
                        "priority": convoy.priority_level,
                        "status": convoy.status
                    })
        
        # Get recommended actions
        analysis["recommended_actions"] = self._get_recommended_actions(obstacle)
        
        return analysis
    
    def _get_recommended_actions(self, obstacle: Obstacle) -> List[str]:
        """Get recommended actions based on obstacle type and severity"""
        rules = COUNTERMEASURE_RULES.get(obstacle.obstacle_type, COUNTERMEASURE_RULES["DEFAULT"])
        
        # Check for severity-specific rules
        severity_key = f"{obstacle.severity}_SEVERITY"
        if severity_key in rules:
            return rules[severity_key]
        elif "ANY" in rules:
            return rules["ANY"]
        elif obstacle.severity in rules:
            return rules[obstacle.severity]
        else:
            return COUNTERMEASURE_RULES["DEFAULT"].get(obstacle.severity, ["WAIT_AND_MONITOR"])
    
    async def generate_countermeasure(self, obstacle: Obstacle) -> Countermeasure:
        """Generate optimal countermeasure for an obstacle"""
        
        # Analyze obstacle first
        analysis = await self.analyze_obstacle(obstacle)
        
        # Select action based on analysis
        action = self._select_optimal_action(obstacle, analysis)
        
        # Select algorithm
        algorithm = self._select_algorithm(action, obstacle)
        
        # Generate decision factors
        decision_factors = self._generate_decision_factors(obstacle, analysis, algorithm)
        
        # Calculate confidence
        confidence = self._calculate_confidence(algorithm, obstacle, analysis)
        
        # Generate execution steps
        steps = self._generate_execution_steps(action, obstacle, analysis)
        
        # Calculate ETA impact
        eta_impact = self._estimate_eta_impact(action, obstacle, analysis)
        
        # Create countermeasure
        countermeasure = Countermeasure(
            obstacle_id=obstacle.id,
            action_type=action,
            decision_algorithm=algorithm["name"],
            confidence_score=confidence,
            decision_factors=decision_factors,
            affected_convoys=[c["id"] for c in analysis["affected_convoys"]],
            affected_assets=[],
            eta_impact_minutes=eta_impact,
            title=self._generate_title(action, obstacle),
            description=self._generate_description(action, obstacle, analysis),
            execution_steps=steps,
            status="PROPOSED"
        )
        
        self.db.add(countermeasure)
        self.decision_count += 1
        
        return countermeasure
    
    def _select_optimal_action(self, obstacle: Obstacle, analysis: Dict) -> str:
        """Select the optimal countermeasure action"""
        recommended = analysis["recommended_actions"]
        
        if not recommended:
            return "WAIT_AND_MONITOR"
        
        # Scoring factors
        action_scores = {}
        for action in recommended:
            score = 100
            
            # Urgency bonus
            if analysis["urgency"] == "IMMEDIATE":
                if action in ["CONVOY_HALT", "EMERGENCY_PROTOCOL"]:
                    score += 50
            
            # Blocked route handling
            if obstacle.blocks_route:
                if action == "ROUTE_DIVERSION":
                    score += 40
                elif action == "WAIT_AND_MONITOR":
                    score -= 30
            
            # Convoy count consideration
            num_convoys = len(analysis["affected_convoys"])
            if num_convoys > 3 and action == "CONVOY_MERGE":
                score += 20
            
            # Priority convoy consideration
            has_critical = any(c["priority"] == "CRITICAL" for c in analysis["affected_convoys"])
            if has_critical and action in ["PRIORITY_ELEVATION", "ESCORT_REQUEST"]:
                score += 30
            
            action_scores[action] = score
        
        # Return highest scoring action
        return max(action_scores, key=action_scores.get)
    
    def _select_algorithm(self, action: str, obstacle: Obstacle) -> Dict:
        """Select the appropriate algorithm for the action"""
        algorithm_map = {
            "ROUTE_DIVERSION": "DIJKSTRA_DIVERSION",
            "PRIORITY_ELEVATION": "PRIORITY_REBALANCE",
            "ASSET_REASSIGNMENT": "GREEDY_REASSIGNMENT",
            "SCHEDULE_DELAY": "MONTE_CARLO_ETA",
            "EMERGENCY_PROTOCOL": "RULE_BASED_EMERGENCY",
            "CONVOY_HALT": "RULE_BASED_EMERGENCY",
            "CONVOY_MERGE": "CONSTRAINT_SATISFACTION",
            "ESCORT_REQUEST": "PRIORITY_REBALANCE"
        }
        
        algo_key = algorithm_map.get(action, "RULE_BASED_EMERGENCY")
        return ALGORITHMS[algo_key]
    
    def _generate_decision_factors(self, obstacle: Obstacle, analysis: Dict, algorithm: Dict) -> Dict:
        """Generate the factors that influenced the decision"""
        return {
            "obstacle_severity": obstacle.severity,
            "obstacle_type": obstacle.obstacle_type,
            "blocks_route": obstacle.blocks_route,
            "affected_convoy_count": len(analysis["affected_convoys"]),
            "urgency_level": analysis["urgency"],
            "algorithm_used": algorithm["name"],
            "impact_score": obstacle.impact_score,
            "estimated_duration_hours": obstacle.estimated_duration_hours,
            "terrain_context": "MOUNTAINOUS",  # Could be dynamic
            "time_of_day": datetime.now().strftime("%H:%M"),
            "weather_factor": 1.0,
            "priority_convoys_affected": sum(1 for c in analysis["affected_convoys"] if c["priority"] in ["HIGH", "CRITICAL"])
        }
    
    def _calculate_confidence(self, algorithm: Dict, obstacle: Obstacle, analysis: Dict) -> float:
        """Calculate confidence score for the decision"""
        base_confidence = algorithm["confidence_base"]
        
        # Adjustments
        adjustments = 0
        
        # More data = more confidence
        if len(analysis["affected_convoys"]) > 0:
            adjustments += 0.03
        
        # Clear severity = more confidence
        if obstacle.severity in ["CRITICAL", "HIGH"]:
            adjustments += 0.02
        
        # Urgency alignment
        if analysis["urgency"] == "IMMEDIATE":
            adjustments -= 0.05  # Less time to analyze
        
        # Known obstacle type
        if obstacle.obstacle_type in ["LANDSLIDE", "FLOODING", "WEATHER_SEVERE"]:
            adjustments += 0.03  # Well-understood obstacles
        
        confidence = min(0.98, max(0.5, base_confidence + adjustments))
        return round(confidence, 2)
    
    def _generate_execution_steps(self, action: str, obstacle: Obstacle, analysis: Dict) -> List[str]:
        """Generate step-by-step execution instructions"""
        steps_map = {
            "CONVOY_HALT": [
                f"Issue HALT command to {len(analysis['affected_convoys'])} affected convoy(s)",
                "Notify convoy commanders of obstacle ahead",
                "Establish secure holding positions",
                "Monitor obstacle status for updates",
                "Prepare for alternative instructions"
            ],
            "ROUTE_DIVERSION": [
                "Calculate alternate route avoiding obstacle zone",
                "Verify alternate route availability and safety",
                "Update navigation systems for affected convoys",
                "Notify TCPs on alternate route",
                "Dispatch advance party if required",
                "Execute diversion for affected convoys",
                "Monitor progress on alternate route"
            ],
            "EMERGENCY_PROTOCOL": [
                "Activate emergency response protocol",
                "Notify command center immediately",
                "Halt all convoy movements in sector",
                "Deploy security/response teams",
                "Establish communication with affected units",
                "Await further instructions from command"
            ],
            "SPEED_ADJUSTMENT": [
                f"Reduce convoy speed to {int(obstacle.speed_reduction_factor * 100)}% in affected zone",
                "Alert convoy commanders of hazardous conditions",
                "Increase inter-vehicle spacing",
                "Enable enhanced monitoring mode",
                "Continue with adjusted parameters"
            ],
            "WAIT_AND_MONITOR": [
                "Continue monitoring obstacle status",
                "Prepare contingency plans",
                f"Re-evaluate in {int(obstacle.estimated_duration_hours * 0.5)} hours",
                "Maintain communication with affected convoys",
                "Update ETA estimates as needed"
            ],
            "SCHEDULE_DELAY": [
                f"Delay departure by {int(obstacle.estimated_duration_hours)} hours",
                "Notify all convoy personnel of delay",
                "Update logistics and supply chain",
                "Re-calculate ETAs for dependent operations",
                "Monitor for earlier clearance"
            ],
            "ESCORT_REQUEST": [
                "Request security escort for high-value convoy",
                "Coordinate with security forces",
                "Prepare convoy for escorted movement",
                "Establish communication protocols with escort",
                "Execute movement under escort"
            ],
            "CONVOY_MERGE": [
                "Identify convoys suitable for merging",
                "Coordinate merge point and timing",
                "Reallocate assets between convoys",
                "Update combined convoy documentation",
                "Execute merged convoy movement"
            ]
        }
        
        return steps_map.get(action, ["Evaluate situation", "Take appropriate action", "Monitor results"])
    
    def _estimate_eta_impact(self, action: str, obstacle: Obstacle, analysis: Dict) -> int:
        """Estimate impact on ETA in minutes"""
        base_impact = {
            "CONVOY_HALT": int(obstacle.estimated_duration_hours * 60),
            "ROUTE_DIVERSION": random.randint(30, 120),  # Diversion adds 30-120 mins
            "EMERGENCY_PROTOCOL": random.randint(60, 240),  # Emergency = significant delay
            "SPEED_ADJUSTMENT": int((1 - obstacle.speed_reduction_factor) * 60),  # Proportional
            "WAIT_AND_MONITOR": random.randint(15, 60),
            "SCHEDULE_DELAY": int(obstacle.estimated_duration_hours * 60),
            "ESCORT_REQUEST": random.randint(30, 90),
            "CONVOY_MERGE": random.randint(20, 60)
        }
        
        return base_impact.get(action, 30)
    
    def _generate_title(self, action: str, obstacle: Obstacle) -> str:
        """Generate countermeasure title"""
        titles = {
            "CONVOY_HALT": f"Halt Order - {obstacle.obstacle_type.replace('_', ' ').title()}",
            "ROUTE_DIVERSION": f"Route Diversion - Avoiding {obstacle.obstacle_type.replace('_', ' ').title()}",
            "EMERGENCY_PROTOCOL": f"EMERGENCY - {obstacle.obstacle_type.replace('_', ' ').upper()}",
            "SPEED_ADJUSTMENT": f"Speed Reduction - {obstacle.obstacle_type.replace('_', ' ').title()} Zone",
            "WAIT_AND_MONITOR": f"Monitor & Hold - {obstacle.obstacle_type.replace('_', ' ').title()}",
            "SCHEDULE_DELAY": f"Delay Operations - {obstacle.obstacle_type.replace('_', ' ').title()}",
            "ESCORT_REQUEST": f"Escort Required - {obstacle.obstacle_type.replace('_', ' ').title()}",
            "CONVOY_MERGE": f"Convoy Consolidation - {obstacle.obstacle_type.replace('_', ' ').title()}"
        }
        return titles.get(action, f"Response to {obstacle.obstacle_type}")
    
    def _generate_description(self, action: str, obstacle: Obstacle, analysis: Dict) -> str:
        """Generate detailed description of the countermeasure"""
        num_convoys = len(analysis['affected_convoys'])
        
        # Handle None values for optional fields
        route_km = obstacle.route_km_marker or 0.0
        duration_hours = obstacle.estimated_duration_hours or 1.0
        impact_score = obstacle.impact_score or 50.0
        speed_factor = obstacle.speed_reduction_factor or 0.5
        
        descriptions = {
            "CONVOY_HALT": f"Halting {num_convoys} convoy(s) due to {obstacle.severity.lower()} severity {obstacle.obstacle_type.replace('_', ' ').lower()}. Estimated obstacle duration: {duration_hours:.1f} hours. All affected vehicles to maintain position until further notice.",
            
            "ROUTE_DIVERSION": f"Diverting {num_convoys} convoy(s) to alternate route due to {obstacle.obstacle_type.replace('_', ' ').lower()} at KM {route_km:.1f}. Route blocks current path with {impact_score:.0f}% impact score. Alternate routing calculated using Dijkstra's algorithm.",
            
            "EMERGENCY_PROTOCOL": f"EMERGENCY: {obstacle.obstacle_type.replace('_', ' ')} detected. Severity: {obstacle.severity}. Immediate halt of all movements. Command center notified. Security protocols activated. {num_convoys} convoy(s) affected.",
            
            "SPEED_ADJUSTMENT": f"Reducing speed to {int(speed_factor * 100)}% for {num_convoys} convoy(s) transiting through {obstacle.obstacle_type.replace('_', ' ').lower()} zone. Enhanced monitoring active. Estimated additional travel time: {self._estimate_eta_impact(action, obstacle, analysis)} minutes.",
            
            "WAIT_AND_MONITOR": f"Monitoring {obstacle.obstacle_type.replace('_', ' ').lower()} situation. Current severity: {obstacle.severity}. Estimated clearance in {duration_hours:.1f} hours. Contingency routes identified. {num_convoys} convoy(s) on standby.",
            
            "SCHEDULE_DELAY": f"Delaying {num_convoys} convoy(s) by approximately {duration_hours:.1f} hours due to {obstacle.obstacle_type.replace('_', ' ').lower()}. All dependent operations notified. Continuous monitoring in effect.",
            
            "ESCORT_REQUEST": f"Requesting armed escort for convoy(s) due to {obstacle.severity.lower()} {obstacle.obstacle_type.replace('_', ' ').lower()} threat. Security forces coordinated. Enhanced protection protocols for {num_convoys} convoy(s).",
            
            "CONVOY_MERGE": f"Consolidating {num_convoys} smaller convoys for enhanced security through {obstacle.obstacle_type.replace('_', ' ').lower()} zone. Optimizing asset distribution. Combined convoy strength provides better resilience."
        }
        
        return descriptions.get(action, f"Countermeasure activated for {obstacle.obstacle_type}")
    
    async def execute_countermeasure(self, countermeasure: Countermeasure) -> bool:
        """Execute a countermeasure (apply changes to convoy/route states)"""
        
        countermeasure.status = "EXECUTING"
        countermeasure.executed_at = datetime.utcnow()
        
        success = True
        outcome_notes = []
        
        try:
            # Execute based on action type
            if countermeasure.action_type == "CONVOY_HALT":
                # Update convoy statuses
                for convoy_id in countermeasure.affected_convoys:
                    await self.db.execute(
                        update(Convoy).where(Convoy.id == convoy_id).values(status="HALTED")
                    )
                outcome_notes.append(f"Halted {len(countermeasure.affected_convoys)} convoy(s)")
                
            elif countermeasure.action_type == "SPEED_ADJUSTMENT":
                # Log speed adjustment (convoy speed is adjusted in simulation)
                outcome_notes.append("Speed adjustments applied to affected convoys")
                
            elif countermeasure.action_type == "ROUTE_DIVERSION":
                # Would calculate and assign new route
                outcome_notes.append("Alternate routes calculated and assigned")
                
            elif countermeasure.action_type == "EMERGENCY_PROTOCOL":
                # Emergency - halt everything
                for convoy_id in countermeasure.affected_convoys:
                    await self.db.execute(
                        update(Convoy).where(Convoy.id == convoy_id).values(status="HALTED")
                    )
                outcome_notes.append("Emergency protocol activated - all movements halted")
            
            # Mark obstacle as countered
            await self.db.execute(
                update(Obstacle).where(Obstacle.id == countermeasure.obstacle_id).values(
                    is_countered=True,
                    countered_at=datetime.utcnow(),
                    countermeasure_id=countermeasure.id
                )
            )
            
            countermeasure.status = "COMPLETED"
            countermeasure.completed_at = datetime.utcnow()
            countermeasure.success = True
            countermeasure.outcome_notes = "; ".join(outcome_notes)
            
        except Exception as e:
            success = False
            countermeasure.status = "FAILED"
            countermeasure.success = False
            countermeasure.outcome_notes = f"Execution failed: {str(e)}"
        
        await self.db.commit()
        return success
    
    def _haversine(self, lat1: float, lon1: float, lat2: float, lon2: float) -> float:
        """Calculate distance in km"""
        R = 6371
        dlat = math.radians(lat2 - lat1)
        dlon = math.radians(lon2 - lon1)
        a = math.sin(dlat/2)**2 + math.cos(math.radians(lat1)) * math.cos(math.radians(lat2)) * math.sin(dlon/2)**2
        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1-a))
        return R * c
